<?xml version='1.0'?>
<!DOCTYPE article[
<!ENTITY mdash "–">
<!ENTITY bc "browser&#x2194;compute">
<!ENTITY implies "⇒">
<!ENTITY deps '<code xmlns="http://docbook.org/ns/docbook">dependencies</code>'>

]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>bdBuild</title>
        <subtitle>Tutorial and Reference Manual</subtitle>
        <copyright>
            <year>2011</year>
            <holder>Rawld Gill</holder>
        </copyright><pubdate>This document was generated <?dbtimestamp format="Y-m-d H:M:S"?>.</pubdate>
        <author>
            <personname>
                <firstname> Rawld </firstname>
                <surname> Gill </surname>
            </personname>
            <affiliation>
                <jobtitle> Chief Engineer </jobtitle>
                <orgname> ALTOVISO LLC </orgname>
            </affiliation>
            <address>
                <street>3478 Buskirk Avenue, Suite 1000</street>
                <city>
                    Pleasant Hill
                </city>
                <postcode>
                    94523
                </postcode>
                <country>
                    USA
                </country>
            </address>
            <email> rgill@altoviso.com </email>
        </author>
        <abstract>
            <para>bdLoad is a program that analyzes and then optimizes a set of resources that
                comprise a browser-based application in order to improve the load-time performance
                of that application. This article describes the motivation, design, and use of
                bdLoad.</para>
            
        </abstract>
    </info>
    <sect1>
        <title>Overview</title>
        <para>bdLoad is a program that transforms a set of resources that comprise a browser-based
            application in order to improve the load-time performance of that application. Two kinds
            of transformations take place<itemizedlist>
                <listitem>
                    <para>The content of resources is analyzed and those portions not required are
                        removed. An example is removing comments from Javascript code.</para>
                </listitem>
                <listitem>
                    <para>Several resources may be bundled into a single resource so that a single
                        server transaction results in downloading several resources. An example is
                        combining several AMD module definitions into a single resource.</para>
                </listitem>
            </itemizedlist> The first transform results in smaller resources which decreases
            transmission time. Further, depending upon the environment, the reduction in resource
            size may result in the user agent caching the resource, thereby completely eliminating
            download time. The second transform results in fewer server transactions which,
            independent of bandwidth, reduces the latenacy costs of loading an application. This
            effect is particularly noticeable when the organization of the program results in a
            serial chain of downloads (for example module A requires module B, but the program
            doesn't know this until module A is evaluated).</para>
        <para>When we talk about transforming resources, clearly we are restricted to transforming
            resources that are static. Obviously, it would be pointless to bundle a bunch of
            real-time stock quotes. For pure browser-based applications (that is, browser
            applications that do not require some kind of plugin), four kinds of static resources
            are typical:<orderedlist>
                <listitem>
                    <para>Javascript source code</para>
                </listitem>
                <listitem>
                    <para>HTML documents and/or document fragments</para>
                </listitem>
                <listitem>
                    <para>CSS style sheets</para>
                </listitem>
                <listitem>
                    <para>Various kinds of text files (for example, templates or JSON)</para>
                </listitem>
            </orderedlist>
        </para>
        <para>There are several kinds of transforms:<orderedlist>
                <listitem>
                    <para>Applying pragmas: typically pragmas cause some code to be
                        included/generated and/or excluded. The excluded code together with the
                        pragmas themselves can be discarded.</para>
                </listitem>
                <listitem>
                    <para>Applying Javascript source code transforms: for example, if Javascript
                        source code uses has.js feature detection and certain features are known to
                        always or never exist, then the code bracketed by the has test can be either
                        included or eliminated and the has test itself discarded.</para>
                </listitem>
                <listitem>
                    <para>Generalized transforms: for example, applying a regular expression
                        replacement to a particular file.</para>
                </listitem>
                <listitem>
                    <para>Minimizing: given the semantics of a resource, certain static analysis and
                        transforms can be applied. For example, removing comments for Javascript
                        source code.</para>
                </listitem>
                <listitem>
                    <para>Bundling: again, given the semantics of a resource, it is possible to
                        execute static analysis and determine all dependencies of a particular
                        resource and then bundle all those dependencies into a single resource.
                        Examples are directly including CSS imports and bundling and AMD module
                        dependency trees.</para>
                </listitem>
            </orderedlist>There are many possibilities with each kind of transformation and I'll
            discuss several in detail. </para>
        <para>The overall design of bdBuild is quite simple. It reads a bunch of resources, applies
            transforms to those resources, and writes the results. The set of source resources.,
            transformations to apply, and write destinations are all controlled by a "build control
            script"--a Javascript object that specifies all the tasks requested of bdBuild. So, in
            order to understand and use bdBuild, we must understand how to construct a build control
            script that.</para>
        <para>TODO</para>
    </sect1>
    <sect1>
        <title>Specifying Source and Destination Resources</title>
        <para>As described above, bdBuild reads and writes a set of resources from one location to
            another, possibly applying a transform between reading and writing. The most-general
            method for specifying a set of resources is to provide file and/or directory source and
            destination names.. bdBuild build control scripts provide three properties for such
            general specifications:<variablelist>
                <varlistentry>
                    <term>files</term>
                    <listitem>
                        <para>an array of <code>[source-filename, dest-filename]</code> that give
                            source and destination filenames</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>dirs</term>
                    <listitem>
                        <para>an array of <code>[source-directory-name, dest-directory-name,
                                    exclude-pattern<subscript>0</subscript>, . . . ,
                                    exclude-pattern<subscript>n</subscript>]</code> that give source
                            and destination directories. The directories are shallow-copied (that
                            is, the directory tree is not recursively copied). The exclude patterns
                            are optional, and if given provide a list of patterns specifying files
                            that should <emphasis>not</emphasis> be copied. Exclude patterns may be
                            either regular expressions or strings.. When a string is provided,
                                "<code>?</code>" matches any single character, "<code>*</code>"
                            matches any number of any character, and the remaining characters must
                            match precisely (this kind of pattern is termed a "glob"
                            pattern).</para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>trees</term>
                    <listitem>
                        <para>the same as dirs except that a deep copy is performed.</para>
                    </listitem>
                </varlistentry>
            </variablelist></para>
        <para>Names may be either relative or absolute filenames.. Source names names are relative
            to the build control script property <code>basePath</code>., and destination names are
            relative to the build control script propety destBasePath. Frequently, baseBase is the
            only absolute path provided in the build control script and all other paths are relative
            to it. There are many ways to specify basePath:<orderedlist>
                <listitem>
                    <para>Via a the command line argument -base-path (see xxx).</para>
                </listitem>
                <listitem>
                    <para>Via the build control script property build.basePath (see xxx)</para>
                </listitem>
                <listitem>
                    <para>Via the build control script property basePath.</para>
                </listitem>
                <listitem>
                    <para>Via the directory in which the build control script resides.</para>
                </listitem>
            </orderedlist>Let's pause a moment and describe the business about build.basePath
            compared to basePath. A build control script can specifiy any property at the root level
            or as a member of the build property; any property found off the build property takes
            precedence. As we move deeper into our exploration of build control scripts, we'll see
            that several properties have identical semantics to those properties in bdLoad
            configuration objects. This isn't surprising since a bdLoad configuration object
            instructions the loader which resources to load in order to execute an application just
            as a build control script instructs bdBuild which resources comprise an application so
            those resources can be optimized. The idea of bdBuild is to allow a single configuration
            object to be maintained for both development loading and building. The build property in
            an otherwise "normal" loader configuration object provides a place to stuff build
            control script properties that are either not applicable to the loader or when you want
            to override dev-time loader properties. I'll talk more about this when we see some real
            examples in xxx.</para>
        <para>So, with all these choices for specifying basePath, which is best? Usually, the best
            is the easiest: don't specify it at all and let bdBuild figure it out from the directory
            that hold the build control script. It's highly likely that you'll have your app under
            version control, and you'll have an established standard for checking out your project
            and any dependent projects from one or more repositories. In order words, you should be
            able to go to some random location in some file hierarchy and checkout your project and
            its dependents, and have all of the resources maintain the same relative position to
            each other. If that's true, then specifying the source and destination for all of your
            application's resources relative to one of those resources--the build control script--is
            the way to go.</para>
        <para>destBasePath is similarly specified:<orderedlist>
                <listitem>
                    <para>Via the command line argument -dest-base-path.</para>
                </listitem>
                <listitem>
                    <para>Vis the build control script properties build.destBasePath</para>
                </listitem>
                <listitem>
                    <para>Via the build control script property destBasePath</para>
                </listitem>
                <listitem>
                    <para>By concatentating basePath with the value of the BC property
                        destBasePathSuffix. If not provided directly, destBasePathSuffix defaults to
                        "-build".</para>
                </listitem>
            </orderedlist></para>
        <para>Again, the easiest thing to do is do nothing and let bdBuild choose the
            default.</para>
        <para>We have more than enough information to write our first build control script. Here it
            is:
<programlisting>
{
  files:[
    ["./dir-to-optionally-copy/resource-to-optionally-copy-1.js", "./build2/dir-to-optionally-copy/resource-to-optionally-copy-1.js"]
  ],

  dirs:[
    ["./js", "./build2/js"]
  ],
  
  trees:[
    ["./css", "./build2/css"]
  ]
}</programlisting>Given
            either <code>baseDir</code> or <code>baseTree</code>, relative sources names found in
                <code>files</code>, <code>dirs</code>, and/or <code>trees</code> are relative to the
            absolute source pathname given by <code>baseDir</code> or <code>baseTree</code>;
            similarly, relative destination names are relative to the absolute destination pathname
            given by <code>baseDir</code> or <code>baseTree</code>. Lastly, in addition to providing
            the base for relative names, specifying <code>baseTree</code> or <code>baseDir</code>
            implies the named pairs are inserted into the <code>trees</code> or <code>dirs</code>
            vectors respectively. Let's take a look at an example build control script that contains
            some these
            elements:<programlisting>{
  baseDir:"/home/rcgill/dev/backdraft/demo/helloWorld",
  
  files:[
    ["../../../bdLoad/lib/require.js", "./require.js"]
  ],

  trees:[
    ["./js", "./js", "*/js/test/*],
    ["./css", "./css"]
  ]
}</programlisting></para>
        <para>This build control script has the following semantics:<orderedlist>
                <listitem>
                    <para>baseDir is "/home/rcgill/dev/backdraft/demo/helloWorld"; all relatives
                        source names found in the <code>files</code>, <code>dirs</code>, and/or
                            <code>trees</code> properties (and others, as we'll soon see) are
                        relative to this path.</para>
                </listitem>
                <listitem>
                    <para>destBaseDir is "/home/rcgill/dev/backdraft/demo/helloWorld-demo";
                        analogously to above, all relative destination names are relative to this
                        path.</para>
                </listitem>
                <listitem>
                    <para>Since destBaseDir implies an entry into dirs, the contents of the
                        directory /home/rcgill/dev/backdraft/demo/helloWorld will be copied to
                        /home/rcgill/dev/backdraft/demo/helloWorld-build. .</para>
                </listitem>
                <listitem>
                    <para>The file
                        /home/rcgill/dev/backdraft/demo/helloWorld/../../../bdLoad/lib/require.js
                        will be copied to
                        /fome/rcgill/dev/backdraft/demo/helloWorld-build/require.js</para>
                </listitem>
                <listitem>
                    <para>The contents of the file system tree rooted at
                        /usr/home/rcgill/dev/backdraft/demo/helloWorld/js with the exception of any
                        filenames tha match the patter "*/js/test/*" will be copied to the tree
                        rooted at /home/rcgill/dev/backdraft/demo/helloWorld-build/js.</para>
                </listitem>
                <listitem>
                    <para>The contents of the file system tree rooted at
                        /usr/home/rcgill/dev/backdraft/demo/helloWorld/css will be copied to the
                        tree rooted at /home/rcgill/dev/backdraft/demo/helloWorld-build/css.</para>
                </listitem>
            </orderedlist></para>
        <para>bdBuild is a node.js porgram. I'll describe all of the command line options in xxx,
            but for now all we need to know is that the option "-b" is used to specify a build
            control script. Assuming the build control script given above is stored as xxx, you can
            execute the build by issuing the following command:</para>
        <para><computeroutput>> node &lt;path-to-bdBuild>/lib/main.js -b xxx</computeroutput></para>
        <para>On my machine, I install all packages at ~/dev, to my command line looks
        like</para>
        <para><computeroutput>> node ~/dev/bdBuild/lib/main.js -b xxx</computeroutput></para>
        <para>provides for three types of sourceand their destination is specified by giving a set
            of file names, directory names, </para>
    </sect1>
    <sect1>
        <title>Design and Implementation</title>
        <para>bdBuild is designed to be highly configurable. The core program begins with routines
            to process the command line and the build control script(s); this results in a single
            build control script that instructs bdBuild on the set of resources to be read,
            transformed, and written. The remainder of the program consists of a simple engine that
            reads each resource as prescribed and then delegates transformation and writing. The
            transformation and writing processes are controlled by the build control script through
            the transformMap and transformJobMap properties.</para>
        <para>transformJobMap instructs bdBuild how to process resources. It consist of a array of
            pairs of predicate functions and arrays of transform names. The predicate functions
            accept a resource filename (complete with path) and return a boolean; the transform
            names are defined by transformMap as we'll see in a moment. As each resource is
            discovered consequent to the packages, trees, dirs, or files build control properties,
            its filename (including the path) is applied to each predicate in the transformJobMap
            array. The first predicate that returns true prescibes the set of transforms to apply to
            the particular resource.</para>
        <para>transformMap descibes transforms. It is a Javascript object that maps a transform name
            to an AMD module and bdBuild phase. As resources are read, transformed, and written,
            they pass through the following phases:<variablelist>
                <varlistentry>
                    <term>read</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>text</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>tokenize</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>tokens</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>parse</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ast</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>optimize</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>write</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>cleanup</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>report</term>
                    <listitem>
                        <para>todo</para>
                    </listitem>
                </varlistentry>
            </variablelist>The AMD module must have the value of a single function:</para>
        <para>TODO define function(resource, buildControl)</para>
        <para>Let's look at an
            example:<programlisting>
transformMap:{
  dojoPragmaProc:["bdBuild/dojoPragmaProc", "text"]
},

transformJobMap:[
  [
    function(filename) {
      return /\.js$/.test(filename);
    },
    [dojoPragmaProc]
  ]
]
</programlisting>.
            . . defines a single transform named "dojoPragmaProc" that is applied during the text
            phase, and then instructs bdBuild to apply that transform to any resource filename that
            end in ".js". When a resource object is passed to the function defined by the AMD module
            bdBuild/dojoPragmaProc, its text property will be initialized with the contents of the
            file controlled by tate particular resource object. Presumeably, the function would then
            modify the text property as instructed by the Dojo pragmas contained with the
            text.</para>
        <para>There are a couple of key points to note in the example. First, each transform
            function may modify the resource object passed to it. So later transforms operate on the
            output of earlier transforms. Since the second element in each pair in the
            transformJobMap is a vector, transform application order is well defined. Second, if no
            read or write transform is provided, bdBuild automatically provides transforms for these
            functions that simply read the resounce from the source filename into the text property
            of the resource object and then write the text property to the destination
            filename.</para>
        <para>All resource processing is defined completely by the transformMap and transformJobMap
            properties in the build control script. Recall that bdBuild constructs the buildControl
            script by mixing all build control scripts indicated by the command line into the
            default build control script. The default build control script defines transformMap and
            transformJobMap as follows:<programlisting>TODO</programlisting>This descibes the
            default build processing of bdBuild. Nevertheless, users can override this default be
            providing additional/different items to transformMap (transformMap may be modified on a
            per item basis) and/or providing a different transformJobMap (transformJobMap must be
            completely replaced).</para>
        <para>a order of transform application is defined. provided to the transform function</para>
        <para>the resource will have been read with the contents of the file stuffed into the text
            property is guarantshould.The AMD module bdBuild/dojoPragmaProc must return a function
            andSee xxx details of the resource and amdResource classes.. The transformMap simply
            associates a name with a function that may be applied to a resource at a particular
            phase</para>
        <para>resource is a Javascript object instantiated from the bdBuild-defined class resource.
            If the resource is an AMD module then it will be derived from the bdBuild-defined class
            amdResource, a subclass of resource.  defined by bdBuild that controls the processing of
            a particular resource. All resource objects have the that takes two argumentss isbdBuild
            provides defaults for these processes.The build control script also as given by the
            build control script. How this deleg</para>
        <para/>
    </sect1>
    <sect1>
        <title>TO DOC</title>
        <para>bc.baseUrl</para>
        <para>kinds of cool transforms:</para>
        <para>transform has feature names to integers; turn it into an array..</para>
        <para>coverset detection of whole program to eliminate dead code</para>
        <para>transform has.js to just get the tests needed; eliminate all calls to has amd
            module</para>
        <para>packageInfo.modules see discovery.processPacakge</para>
        <para>dojoPragmaKwArgs</para>
        <para>noDefaultPackage</para>
        <para>&lt;check defaultBuildControl></para>
        <para>closure does not do common subexpr elimination</para>
        </sect1>
</article>
